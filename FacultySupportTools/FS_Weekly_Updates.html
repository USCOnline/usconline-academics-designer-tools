<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Table Transformer</title>
<style>
body {
	font-family: sans-serif;
	padding: 1rem;
	max-width: 800px;
	margin: auto;
}
textarea {
	width: 100%;
	height: 200px;
	margin-bottom: 1rem;
	font-family: monospace;
}
button {
	margin-right: 1rem;
	padding: 0.5rem 1rem;
}
#weekInfoDisplay {
	padding: 0.75rem;
	background-color: #f1f1f1;
	border-left: 4px solid #0077cc;
	margin: 1rem 0;
}
#weekInfoDisplay strong {
	display: block;
	margin-bottom: 0.25rem;
}
.contenteditable-container {
	display: block;
	max-height: 200px;
	padding: 15px;
	border: 1px solid #ccc;
	margin: 15px;
	overflow: auto;
}
.contenteditable {
	min-height: 200px;
	outline: none;
}
#renderedPreview {
	border: 1px solid #ccc;
/*	background-color: #f9f9f9;*/
	padding: 1rem;
	margin-top: 2rem;
}
</style>
</head>
<body>
<h1>Table to HTML Transformer</h1>
<label for="inputHTML">Paste your table HTML here:</label>
<div id="inputHTML">
	<div class="contenteditable-container">
		<div id="input" class="contenteditable" contenteditable="true" aria-label="Input Box"></div>
	</div>
</div>
<button id="generateBtn">Generate</button>
<label for="outputHTML">Transformed HTML:</label>
<textarea id="outputHTML" readonly></textarea>
<button id="copyBtn">Copy Code</button>

<!-- Rendered Preview -->
<hr>
<h2>Rendered Preview:</h2>
<div id="weekInfoDisplay"> <strong>Week Info:</strong>
	<div id="weekInfoContent">(Nothing yet)</div>
</div>
<div id="renderedPreview">(Nothing yet)</div>
<script>
  document.getElementById('generateBtn').addEventListener('click', () => {
    const input = document.getElementById('input').innerHTML;

    console.log("Raw input innerHTML BEFORE parsing:\n", input);

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = input;

    const allRows = tempDiv.querySelectorAll('table tr');
    const rowArray = Array.from(allRows);
    const weekInfoContent = document.getElementById('weekInfoContent');

    if (rowArray.length > 0) {
      console.log("Extracted first <tr>:", rowArray[0]);
      weekInfoContent.innerHTML = rowArray[0].innerHTML;
    } else {
      console.warn("No <tr> found in input.");
      weekInfoContent.innerHTML = '<em>No row 1 (week info) found</em>';
    }

    const contentRows = rowArray.slice(2, -1);

    let outputHTML = "";

    contentRows.forEach((row, i) => {
      const cells = row.cells;
      const firstCellHTML = cells[0]?.innerHTML.trim();
      const thirdCellHTML = cells[2]?.innerHTML.trim();

      if (firstCellHTML) {
        outputHTML += `<p>${firstCellHTML}</p>\n`;
      }

      if (thirdCellHTML) {
        outputHTML += `<p>${thirdCellHTML}</p>\n`;
      }

      outputHTML += `<p>&nbsp;</p>\n`;
    });

    const cleaner = document.createElement('div');
    cleaner.innerHTML = outputHTML;

    const allParagraphs = cleaner.querySelectorAll('p');

    allParagraphs.forEach(p => {
      const childPs = Array.from(p.children).filter(el => el.tagName === 'P');
      if (childPs.length === 1 && p.children.length === 1) {
        p.replaceWith(childPs[0]);
      }
    });

    const allCleanedParagraphs = cleaner.querySelectorAll('p');

    allCleanedParagraphs.forEach(p => {
      const isActuallyEmpty =
        (p.textContent.trim() === "" || p.innerHTML.trim() === "") &&
        p.children.length === 0;
      const isNonBreakingSpace = p.innerHTML.trim() === "&nbsp;";
      if (isActuallyEmpty && !isNonBreakingSpace) {
        p.remove();
      }
    });

    const styledElements = cleaner.querySelectorAll('[style]');

    styledElements.forEach(el => {
      const style = el.getAttribute('style') || "";
      if (/font-weight\s*:\s*700/.test(style)) {
        const strong = document.createElement('strong');
        strong.innerHTML = el.innerHTML;
        el.replaceWith(strong);
      }
    });

    const italicStyledElements = cleaner.querySelectorAll('[style]');

    italicStyledElements.forEach(el => {
      const style = el.getAttribute('style') || "";
      if (/font-style\s*:\s*italic/i.test(style)) {
        const em = document.createElement('em');
        em.innerHTML = el.innerHTML;
        const colorMatch = style.match(/color\s*:\s*[^;]+/i);
        const colorStyle = colorMatch ? colorMatch[0] : "";
        el.setAttribute("style", colorStyle);
        el.innerHTML = "";
        el.appendChild(em);
      }
    });
	  
	// Strip all style attributes except 'color: rgb(255, 0, 255)'
	const elementsWithStyle = cleaner.querySelectorAll('[style]');

	elementsWithStyle.forEach(el => {
	  const originalStyle = el.getAttribute('style') || "";
	  const colorMatch = originalStyle.match(/color\s*:\s*rgb\(\s*255\s*,\s*0\s*,\s*255\s*\)/i);

	  if (colorMatch) {
		el.setAttribute('style', 'color: rgb(255, 0, 255)');
	  } else {
		el.removeAttribute('style');
	  }
	});
	  
	// Remove all <span> tags with no attributes
	const allSpans = cleaner.querySelectorAll('span');

	allSpans.forEach(span => {
	  if (!span.attributes.length) {
		// If no attributes, unwrap the span (preserve its children)
		const parent = span.parentNode;
		while (span.firstChild) {
		  parent.insertBefore(span.firstChild, span);
		}
		parent.removeChild(span);
	  }
	});

	// Remove all dir="ltr" attributes
	const allElementsWithDir = cleaner.querySelectorAll('[dir]');
	allElementsWithDir.forEach(el => {
	  if (el.getAttribute('dir') === 'ltr') {
		el.removeAttribute('dir');
	  }
	});
	  
	// Remove any element that contains a descendant styled with pink
	const pinkElements = cleaner.querySelectorAll('[style*="rgb(255, 0, 255)"]');

	pinkElements.forEach(pinkEl => {
	  // Traverse up to the nearest <p> or other removable block container
	  let current = pinkEl;
	  while (current && current !== cleaner) {
		if (['P', 'DIV', 'LI'].includes(current.tagName)) {
		  current.remove();
		  break;
		}
		current = current.parentElement;
	  }
	});

	// Remove specific <p> elements based on exact simplified content
	const paragraphsToRemove = [
	  '&nbsp;',
	  '<strong>added</strong>',
	  '<strong>pending</strong>',
	  '<strong>omitted</strong>',
	  '<em>[opener]</em>',
	  '<em>[closer]</em>'
	];

	cleaner.querySelectorAll('p').forEach(p => {
	  let html = p.innerHTML
		.replace(/\s+/g, ' ')       // collapse all whitespace
		.replace(/>\s+</g, '><')    // remove space between tags
		.trim()
		.toLowerCase();

	  if (paragraphsToRemove.includes(html)) {
		p.remove();
	  }
	});
	  
	// Flatten <p> inside all <li> and remove aria-level attributes
	cleaner.querySelectorAll('li').forEach(li => {
	  // Remove aria-level attribute
	  li.removeAttribute('aria-level');

	  // Flatten <p> only if it's the sole child of <li>
	  const onlyChild = li.children.length === 1 ? li.children[0] : null;
	  if (onlyChild && onlyChild.tagName === 'P') {
		li.innerHTML = onlyChild.innerHTML;
	  }
	});



    outputHTML = cleaner.innerHTML;

	// Prepend template to output
	const template = `<p><img style="display: block; margin-left: auto; margin-right: auto;" role="presentation" src="https://courses.bovardcollege.usc.edu/courses/221/files/25882/preview" alt="" width="268" height="54" data-api-endpoint="https://courses.bovardcollege.usc.edu/courses/221/files/25882/preview" data-api-returntype="File" /></p>
	<p style="text-align: center;"><strong>Weekly Faculty Update</strong></p>
	<p><em>Note: To access links, files, and embedded media in Canvas announcements, select "view announcement" at the bottom of the email notification to open the message in Canvas.</em></p>
	`;

	outputHTML = template + outputHTML;

	document.getElementById('outputHTML').value = outputHTML || "(No content generated)";
	document.getElementById('renderedPreview').innerHTML = outputHTML || "(No content generated)";

    document.getElementById('outputHTML').value = outputHTML || "(No content generated)";
    document.getElementById('renderedPreview').innerHTML = outputHTML || "(No content generated)";
  });

  document.getElementById('copyBtn').addEventListener('click', () => {
    const outputArea = document.getElementById('outputHTML');
    outputArea.select();
    document.execCommand('copy');
  });
</script>
</body>
</html>
